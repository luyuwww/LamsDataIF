1、 创建 middb
        --这里用s_all的maxdid+1 作为426\427的替代,
        INSERT INTO s_all VALUES ('426', 'P_MIDDB', '中间库信息表', '1', '2', null, '');
        INSERT INTO s_all VALUES ('427', 'P_MIDTB', '中间表信息表', '1', '2', null, '');

        CREATE TABLE F_P_MIDDB (
          DID int NOT NULL PRIMARY KEY,
          FIELDNAME varchar(32) NOT NULL,
          CHNAME varchar(64) NOT NULL,
          FIELDTYPE int NOT NULL,
          LENGTH int DEFAULT NULL,
          NOTNULL int DEFAULT NULL,
          NOTDUP int DEFAULT NULL,
          NOTINWEB int DEFAULT NULL,
          FCATTR int DEFAULT NULL,
          FMATTR int DEFAULT NULL,
          READONLYCOLS varchar(16) DEFAULT NULL
        );

        INSERT INTO F_P_MIDDB VALUES ('1', 'DID', 'DID', '3', '50', '1', '1', '0', '1', '0', '0100000111000000');
        INSERT INTO F_P_MIDDB VALUES ('2', 'DALXCHNAME', 'DALXCHNAME', '1', '50', '1', '0', '0', '1', '0', '0100000111000000');
        INSERT INTO F_P_MIDDB VALUES ('3', 'LIBCODE', 'LIBCODE', '3', '49', '1', '0', '0', '1', '0', '0100000111000000');
        INSERT INTO F_P_MIDDB VALUES ('4', 'DBURL', 'DBURL', '1', '65', '1', '1', '0', '1', '0', '0100000111000000');
        INSERT INTO F_P_MIDDB VALUES ('5', 'DBNAME', 'DBNAME', '1', '50', '1', '1', '0', '1', '0', '0100000111000000');
        INSERT INTO F_P_MIDDB VALUES ('6', 'DBTYPE', 'DBTYPE', '1', '50', '1', '1', '0', '1', '0', '0100000111000000');
        INSERT INTO F_P_MIDDB VALUES ('7', 'USERNAME', 'USERNAME', '1', '50', '1', '1', '0', '1', '0', '0100000111000000');
        INSERT INTO F_P_MIDDB VALUES ('8', 'PASSWORD', 'PASSWORD', '1', '50', '1', '1', '0', '1', '0', '0100000111000000');
        INSERT INTO F_P_MIDDB VALUES ('9', 'MAXLEVEL', 'MAXLEVEL', '1', '50', '1', '1', '0', '1', '0', '0100000111000000');
        INSERT INTO F_P_MIDDB VALUES ('10', 'BZ', 'BZ', '1', '512', '0', '0', '0', '1', '0', '0100000111000000');


        CREATE TABLE F_P_MIDTB (
          DID int NOT NULL  PRIMARY KEY ,
          FIELDNAME varchar(32) NOT NULL,
          CHNAME varchar(64) NOT NULL,
          FIELDTYPE int NOT NULL,
          LENGTH int DEFAULT NULL,
          NOTNULL int DEFAULT NULL,
          NOTDUP int DEFAULT NULL,
          NOTINWEB int DEFAULT NULL,
          FCATTR int DEFAULT NULL,
          FMATTR int DEFAULT NULL,
          READONLYCOLS varchar(16) DEFAULT NULL );

        INSERT INTO F_P_MIDTB VALUES ('1', 'PID', 'PID', '3', '50', '1', '1', '0', '1', '0', '0100000111000000');
        INSERT INTO F_P_MIDTB VALUES ('2', 'DID', 'DID', '3', '50', '1', '1', '0', '1', '0', '0100000111000000');
        INSERT INTO F_P_MIDTB VALUES ('3', 'STBNAME', 'STBNAME', '1', '50', '1', '1', '0', '1', '0', '0100000111000000');
        INSERT INTO F_P_MIDTB VALUES ('4', 'TTBNAME', 'TTBNAME', '1', '50', '1', '1', '0', '1', '0', '0100000111000000');
        INSERT INTO F_P_MIDTB VALUES ('5', 'MTBNAME', 'MTBNAME', '1', '50', '1', '1', '0', '1', '0', '0100000111000000');
        INSERT INTO F_P_MIDTB VALUES ('6', 'SSQL', 'SSQL', '1', '1000', '1', '1', '0', '1', '0', '0100000111000000');
        INSERT INTO F_P_MIDTB VALUES ('7', 'PIDSQL', 'PIDSQL', '1', '1000', '0', '0', '0', '1', '0', '0100000111000000');
        INSERT INTO F_P_MIDTB VALUES ('8', 'CALLBACKSQL', 'CALLBACKSQL', '1', '1000', '0', '0', '0', '1', '0', '0100000111000000');
        INSERT INTO F_P_MIDTB VALUES ('9', 'BZ', 'BZ', '1', '100', '0', '0', '0', '1', '0', '0100000111000000');
        INSERT INTO F_P_MIDTB VALUES ('10', 'DEFAULTFIELD', 'DEFAULTFIELD', '1', '1000', '0', '0', '0', '1', '0', '0100000111000000');
        INSERT INTO F_P_MIDTB VALUES ('11', 'DEFAULTVALUE', 'DEFAULTVALUE', '1', '1000', '0', '0', '0', '1', '0', '0100000111000000');
        INSERT INTO F_P_MIDTB VALUES ('12', 'UPDATESQL', 'UPDATESQL', '1', '1000', '0', '0', '0', '1', '0', '0100000111000000');

        执行完点击创建库（代码库管理）☆☆☆☆

        下面创建字段对应表
        1. 添加代码库。录入名字
        2. s_all找到表名(左侧代码表列表也可以看到)，或者代表列表里面看到，比如是： P_428
        3. 修改对应脚本。替换表名
        4. 执行insert 别忘记替换表名
        5. 创建库，可以添加数据，创建源表和目标表的关系了
        CREATE TABLE F_P_428 (
          DID int NOT NULL  PRIMARY KEY,
          FIELDNAME varchar(32) NOT NULL,
          CHNAME varchar(64) NOT NULL,
          FIELDTYPE int NOT NULL,
          LENGTH int DEFAULT NULL,
          NOTNULL int DEFAULT NULL,
          NOTDUP int DEFAULT NULL,
          NOTINWEB int DEFAULT NULL,
          FCATTR int DEFAULT NULL,
          FMATTR int DEFAULT NULL,
          READONLYCOLS varchar(16) DEFAULT NULL);

          INSERT INTO F_P_428 VALUES ('1', 'PPID', 'PPID', '3', '50', '1', '1', '0', '1', '0', '0100000111000000');
          INSERT INTO F_P_428 VALUES ('2', 'PID', 'PID', '3', '50', '1', '1', '0', '1', '0', '0100000111000000');
          INSERT INTO F_P_428 VALUES ('3', 'DID', 'DID', '3', '50', '1', '1', '0', '1', '0', '0100000111000000');
          INSERT INTO F_P_428 VALUES ('4', 'SFIELD', 'SFIELD', '1', '64', '1', '1', '0', '1', '0', '0100000111000000');
          INSERT INTO F_P_428 VALUES ('5', 'TFIELD', 'TFIELD', '1', '64', '1', '1', '0', '1', '0', '0100000111000000');
          INSERT INTO F_P_428 VALUES ('6', 'DEFAULTVALUE', 'DEFAULTVALUE', '1', '64', '0', '0', '0', '1', '0', '0100000111000000');
          INSERT INTO F_P_428 VALUES ('7', 'BZ', 'BZ', '1', '1000', '0', '0', '0', '1', '0', '0100000111000000');


--以上过程所需的表就创建完了，可以在代码表里面进行编辑了。
设计思路
1.  创建 midtb
2.  middb添加一个数据库记录   1
3.  midtb添加若干表对应关系      N
    如果有ssql （以select开头）（源表查询语句）就使用这个语句。但是里面的每个字段都要放在字段对应关系中 + defaultfield
    如果没有ssql（以where开头）（源表查询语句） 就只用字段对应关系的字段，+defaultfield
4.  字段映射关系添加字段关系   1
5.  建议将老表的主键保存在新表一个字段中



调用过程
1. 遍历中间库表 P_MIDDB
2. 遍历儿子中间表 P_MIDTB
    a. 利用P_MIDTB.SSQL或者字段对应关系 + defaultfield 分页查询,
    b. 获取结果集 逐条插入目标表，(判断是否是顶级(midtab.did=1是顶级)，如果不是需要调用pidsql，没有查询到写-1)
    c. 调用updatesql去更新源表的同步标识
    d. 一个循环完毕。调用callbacksql，来更新目标表(hams)的一些状态，如果没有就算了
    e. 如果有电子文件，写到搬运工的地方。让搬运工来分发。（写入的时候判断电子文件是否存在。如果存在要给新文件加上时间戳）
    f. 成功错误写日志

    细节midtab.ssql一定要有主键，主键的别名一定要改成DID，DID是主键，会自动用在后面update语句 ,语句开头必须以SELECT或者WHERE开头
    细节  自定义函数 别名要填写备注里面
    细节midtab.updatesql组成  成功update子句;失败update子句;where字段  eg：flag=1;flag=2;prjcode
        （第一段是正确执行的语句，第二句是错误执行的。第三段是源表主键字段会默认和查询出来的did作为筛选更新条件）
    细节midtab.pidsql组成  父表查询语句包括表名;父表字段;源表的取值字段  eg：select did from d_prj3;prjcode;prjcode
    细节D表的字段中映射关系表中一定要有qzh和bmid字段，不需要DID和PID字段，可以用函数实现
    e_file表的对应关系一定要求 PZM，TITLE，PATHNAME，EFILENAME字段。对应S_FWQPZ里面的配置信息

    ☆☆☆写语句的是 ' 用 ` 代替
   ======================================================
文件小工具
    针对thamsxp的数据不用考虑电子文件 直接整个电子文件copy就可以
    针对接口的电子文件理论上不用对应e表。e表的数据是根据文件名对应的。
    其他的文件需要可以配置

    所以在写文件分发工具的时候有几点要配置：
        1. 配置是否删除源文件，如果不删除移动到目标backup文件夹，
        2. 日志，同步过程中有一个错误，将文件放到error文件，并且同级目录加日志 文件名.err
        3. 配置写入主库是否插入e表，插入e表，对应d表的字段是什么。（不插入E表，就是thamsxp的数据）
        4. 配置是 原设计文件或板式文件，方别写入E表
        5. 写入有顺序，写入档案系统e表-->得到相对路径-->copy到档案系统相对路径-->copy文件到外部分发系统的相对相对路径 哈哈

其他说明-------------------------------------------------------``````````
一般不用系统录入和挂接,
条目通过中间库程序搞定,电子文件通过柯工的搬运工搞定.
下面是和柯工讨论的记过径路
2020-7-28沟通
陆工，咱们统一一下：电子文件分为两种类型：
1、源文件：由业务系统产生和流转，并在业务系统的流程结束后归档进入电子档案管理系统的电子文件。文件的格式多样，多数可以编辑。
2、版式文件：为长期保存和可靠利用，由源电子文件转换或通过数字化扫描加工而成的电子文件。格式为PDF文件。

文件:文档:元素的关系是  1:N:N
使用
浏览：统一浏览版式文件
下载:  选择或者权限控制 是下载版式文件还是源文件（也可以设计成只下载源文件），下载的源文件如果是组合文档下载成zip,如果是简单文件下载成单个文件。

显示电子文件列表：只显示源文档和源文档所属的元素文档，不显示版式文件（是否有版式文件由题名颜色或一列做说明）

收集
1.正常接口过来如果版式文件和源文件一起过来要给明显的字段做区分
2.转换程序会转换单个文件，针对复杂组合文件放弃转换
3.复杂文档上传对应的版式文件，需要指定所对应的源文件关系.
4.手动上传复杂的源文件，要标识每个文件是主文档还是元素文档。

这里要注意在电力设计院需要屏蔽系统的上传功能. 会通过小程序进行同步.
同步如果是单个文件我们就直接同步,如果是文件夹我们就变成zip文件去同步.

---------------------------
2020-8-11 更新
3.4 实现方法：数据库在原有“文件表”的基础上增加一个“电子文件表”。该表的主要功能为：1）记录电子文件所属的类型（源文件、版式文件）；2）复合文件在收集、传输、下载时，所有的组件都放在同一个压缩文件中，不区分主文件和附属文件。压缩文件的命名用“文件编号”来进行命名。将复合文件作为一个整体单元执行相应操作；3）单个文件在收集、传输、下载时直接以单个文件进行利用。4）“电子文件表”中的记录通过某个字段值与“文件表”中的记录进行关联，明确电子文件的所属关系。
“文件表”中需要有字段记录某条文件记录下的源文件、版式文件是否存在，以便在用户界面上进行直观的展示。用户通过界面只知道是否有源文件或版式文件，并不知道文件是复合文件或单个文件，以及包含哪些组件，在执行下载操作后才可以看到电子文件所有的组件。这样做的好处是：能够简化软件设计，同时给用户传递明确而有用的信息，不至于看到一长串的文件清单而不知所措。
3.5 电子文件的利用
电子文件下载：
用户在申请下载电子文件时，提示用户选择下载“源文件”、“版式文件”或者所有类型的文件。用户可以同时申请下载多个卷册的电子文件。用户申请的内容形成列表发送给审批者进行审批。在申请得到批准后，按批准的内容进行电子文件下载。
电子文件浏览：
单个文件浏览：首选浏览版式文件，版式文件不存在将自动浏览源文件
复合文件浏览：首选浏览版式文件，版式文件不存在提示不存在。

